function Enemy(t,i,o,n,e){Entity.call(this,t,i,o,n),this.moveType=e,this.isAttacking=!1}function Entity(t,i,o,n){Tile.call(this,t,i,!1),this.health=o,this.maxHealth=o,this.power=n,this.direction=0}function Item(t,i,o){Tile.call(this,t,i,!1),this.buff=o}function Tile(t,i,o){this.i=t,this.j=i,this.isEmpty=o}Enemy.prototype.__proto__=Entity.prototype,Enemy.prototype.draw=function(t){this.__proto__.__proto__.__proto__.draw.call(this,t),t.addClass("enemy"),this.drawHealthBar(t),this.drawHealthPoints(t),this.isAttacking&&t.addClass("attack")},Entity.prototype.__proto__=Tile.prototype,Entity.prototype.draw=function(t){this.mirrorFlip(t)},Entity.prototype.drawHealthBar=function(t){const i=Math.ceil(this.health/this.maxHealth*100),o=$("<div></div>");o.attr("class","health"),o.css("width",i+"%"),t.append(o)},Entity.prototype.drawHealthPoints=function(t){const i=$(`<p>${this.health} HP</p>`);i.attr("class","healthPoint"),t.append(i)},Entity.prototype.removeHealthPoints=function(t){t.find(".healthPoint").remove()},Entity.prototype.changeDirection=function(t){t===Action.RIGHT&&(this.direction=1),t===Action.LEFT&&(this.direction=-1)},Entity.prototype.mirrorFlip=function(t){this.direction>0?t.addClass("right"):t.addClass("left")},Item.prototype.__proto__=Tile.prototype,Tile.prototype.draw=function(t){t.addClass("wall")};