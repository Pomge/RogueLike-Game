function getFreeCells(e){let t=[];for(let n=0;n<e.height;n+=1)for(let o=0;o<e.width;o+=1)if(e.gameZone[n][o].isEmpty){const e={i:n,j:o};t.push(e)}return t}function isHaveFreeCells(e,t,n){for(let o=0;o<n;o+=1)for(let n=0;n<t;n+=1)if(e[o][n])return!0;return!1}function getFreeCellsByBorders(e,t){let n=[];for(let o=t.minVerticalBorder;o<=t.maxVerticalBorder;o+=1)for(let i=t.minHorizontalBorder;i<=t.maxHorizontalBorder;i+=1)e[o][i]&&n.push({i:o,j:i});return n}function createGameZone(e,t){let n=[];for(let o=0;o<t;o+=1){n[o]=[];for(let t=0;t<e;t+=1)n[o][t]=new Tile(o,t,!1)}return{gameZone:n,width:e,height:t}}function generateRooms(e,t,n,o,i){const a=getRandomIntInRange(t,n);let r=e.height,s=0,c=e.width,l=0;for(let t=0;t<a;t+=1){const t=getRandomIntInRange(o,i),n=getRandomIntInRange(o,i),a=getRandomIntInRange(0,e.height-n),m=getRandomIntInRange(0,e.width-t),p=a+n,d=m+t;for(let t=a;t<p;t+=1)for(let n=m;n<d;n+=1)e.gameZone[t][n].isEmpty=!0;a<r&&(r=a),p>s&&(s=p),m<c&&(c=m),d>l&&(l=d)}r+=o,c+=o,s-=o,l-=o;const m={minVerticalBorder:r,maxVerticalBorder:s,minHorizontalBorder:c,maxHorizontalBorder:l};return m}function getRandomIndex(e,t,n){for(;;){const o=getRandomIntInRange(e,t);if(-1===n.indexOf(o))return n.push(o),o;n.push(o)}}function generateWays(e,t,n,o){const i=getRandomIntInRange(t,n),a=getRandomIntInRange(t,n),r=[];for(let t=0;t<i;t+=1){const t=getRandomIndex(o.minVerticalBorder,o.maxVerticalBorder,r);for(let n=0;n<e.width;n+=1)e.gameZone[t][n].isEmpty=!0}const s=[];for(let t=0;t<a;t+=1){const t=getRandomIndex(o.minHorizontalBorder,o.maxHorizontalBorder,s);for(let n=0;n<e.height;n+=1)e.gameZone[n][t].isEmpty=!0}}function collectSteps(e,t,n,o,i,a){o+1<n&&e[o+1][i]&&(a.push({i:o+1,j:i}),e[o+1][i]=!1),i+1<t&&e[o][i+1]&&(a.push({i:o,j:i+1}),e[o][i+1]=!1),o-1>=0&&e[o-1][i]&&(a.push({i:o-1,j:i}),e[o-1][i]=!1),i-1>=0&&e[o][i-1]&&(a.push({i:o,j:i-1}),e[o][i-1]=!1),e[o][i]=!1}function isMapHaveEmptySpaces(e,t){const n=e.width,o=e.height;let i=copyGameZone(e);const a=getFreeCellsByBorders(i,t),r=a[Math.ceil(a.length/2)],s=r.i,c=r.j;let l=[];for(collectSteps(i,n,o,s,c,l);0!=l.length;){let e=[];for(let t=0;t<l.length;t+=1){const a=l[t],r=a.i,s=a.j;collectSteps(i,n,o,r,s,e)}l=e}return isHaveFreeCells(i,n,o)}function spawnEntity(e,t,n){const o=t.i,i=t.j,a=n[0],r=n[1],s=n[2],c=n[3];e.gameZone[o][i]=new a(o,i,r,s,c)}function spawnItem(e,t,n){const o=t.i,i=t.j,a=n[0],r=n[1];e.gameZone[o][i]=new a(o,i,r)}function spawnObjects(e,t,n,...o){for(let i=0;i<t;i+=1){const t=getFreeCells(e),i=getRandomIntInRange(0,t.length-1),a=t[i];n(e,a,o)}}function gameGenerator(e){let t={},n={};do{t=createGameZone(e.width,e.height),n=generateRooms(t,e.minRoomCount,e.maxRoomCount,e.minRoomSize,e.maxRoomSize),generateWays(t,e.minWaysCount,e.maxWaysCount,n)}while(isMapHaveEmptySpaces(t,n));spawnObjects(t,e.swordCount,spawnItem,Sword,e.swordBuff),spawnObjects(t,e.potionCount,spawnItem,Potion,e.potionBuff),spawnObjects(t,1,spawnEntity,Player,e.playerHealth,e.playerPower);let o=[];const i=e.enemyCount;let a=0;const r=Object.keys(EnemyMoveType).length-1;for(let e=0;e<r;e+=1){let t=0;if(e!==r-1){const n=r-e-1;t=getRandomIntInRange(1,i-n-a)}else t=i-a;let n={};switch(n.count=t,n.moveType=getEnemyMoveType(e),n.moveType){case EnemyMoveType.HORIZONTAL:case EnemyMoveType.VERTICAL:n.class_=LinearEnemy;break;case EnemyMoveType.RANDOM:n.class_=RandomEnemy;break;case EnemyMoveType.HUNTER:n.class_=HunterEnemy}o.push(n),a+=t}for(let n=0;n<o.length;n+=1){const i=o[n];spawnObjects(t,i.count,spawnEntity,i.class_,e.enemyHealth,e.enemyPower,i.moveType)}return t}function moveEntity(e,t,n,o){const{indexDiff:i,jndexDiff:a}=getIndexJndex(t),r=n.i,s=n.j;let c=mapTeleport(r+i,e.height),l=mapTeleport(s+a,e.width),m=e.gameZone[c][l];o&&(n.changeDirection(t),m.__proto__===Potion.prototype?(n.drinkPotion(m),m=new Tile(m.i,m.j,!0)):m.__proto__===Sword.prototype&&(n.takeSword(m),m=new Tile(m.i,m.j,!0))),m.isEmpty&&(e.gameZone[c][l]=n,n.i=c,n.j=l,e.gameZone[r][s]=m,m.i=r,m.j=s)}function moveEnemies(e,t,n){for(let o=0;o<t.length;o+=1){const i=t[o],a=i.step(e,n);moveEntity(e,a,i,!1)}}function calculateAttacks(e,t,n,o){const i=t.i,a=t.j;let r=[];for(let e=0;e<n.length;e+=1){const s=n[e],c=s.i,l=s.j,m=Math.abs(c-i)<=1&&Math.abs(l-a)<=1;s.isAttacking=m,m&&(o&&(s.health-=t.power),s.health<=0?r.push(s):t.health-=s.power)}for(let t=r.length-1;t>=0;t-=1){const n=r[t],o=n.i,i=n.j;e.gameZone[o][i]=new Tile(o,o,!0)}}function draw(){const e=$(".field");for(let t=0;t<map.height;t+=1)for(let n=0;n<map.width;n+=1){const o=map.gameZone[t][n];if(!o.isEmpty){const i=$("<div></div>");i.attr("class","field"),i.width(multiplier).height(multiplier),i.offset({top:multiplier*t,left:multiplier*n}),o.draw(i),e.append(i)}}}function isGameOver(){const e=getObjectsByInstanceOf(map,Player)[0],t=getObjectsByInstanceOf(map,Enemy);if(0===t.length||e.health<=0){const e=0===t.length?"Win":"Lose";setTimeout(function(){confirm("Game Over: "+e),window.location.reload()},0)}}function update(e){$(".field").empty(),gameStep(map,e),draw(),isGameOver()}const gameStep=(e,t)=>{const n=getObjectsByInstanceOf(e,Player)[0];let o=getObjectsByInstanceOf(e,Enemy);moveEnemies(e,o,n),t!==Action.ATTACK&&moveEntity(e,t,n,!0),calculateAttacks(e,n,o,t===Action.ATTACK)};var map={};let multiplier=35;document.addEventListener("keypress",e=>{const t=e.key.toLocaleLowerCase();let n=Action.UNKNOWN;switch(t){case"w":case"ц":n=Action.UP;break;case"d":case"в":n=Action.RIGHT;break;case"s":case"ы":n=Action.DOWN;break;case"a":case"ф":n=Action.LEFT;break;case" ":n=Action.ATTACK}update(n)}),window.addEventListener("resize",e=>{const t=$(window).width(),n=$(window).height(),o=map.width,i=map.height;multiplier=Math.ceil(.95*Math.min(t/o,n/i));const a=$(".field-box");a.width(multiplier*o).height(multiplier*i),a.css("background-size",`${multiplier}px`),$(".field").empty(),draw()});const registerServiceWorker=async()=>{if("serviceWorker"in navigator)try{await navigator.serviceWorker.register("./serviceWorker.js")}catch(e){console.error(`Service Worker registration failed with ${e}`)}};window.addEventListener("load",async e=>{await registerServiceWorker();const t=Settings;map=gameGenerator(t),window.dispatchEvent(new Event("resize"))});